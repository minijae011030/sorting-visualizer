[
  {
    "method": "selection",
    "code": "// 선택 정렬 함수\nvoid selectionSort(int* arr, int arr_len) {\n    // 배열의 마지막 요소부터 첫 번째 요소까지 반복\n    for (int i = arr_len - 1; i > 0; i--) {\n        int max_idx = i; // 현재 배열에서 최대값의 인덱스를 저장\n        // 배열의 처음부터 현재 위치까지 반복하며 최대값 탐색\n        for (int j = 0; j <  i; j++) {\n            if (arr[j] > arr[max_idx]) {\n                max_idx = j; // 최대값의 인덱스를 갱신\n            }\n        }\n\n        // 최대값이 현재 위치에 있는 값과 다르면 교환\n        if (max_idx != i) {\n            int tmp = arr[i];\n            arr[i] = arr[max_idx];\n            arr[max_idx] = tmp; // 최대값과 현재 값을 교환\n        }\n    }\n}\n"
  },
  {
    "method": "insertion",
    "code": "// 삽입 정렬 함수\nvoid insertionSort(int* arr, int arr_len) {\n    // 배열의 두 번째 요소부터 마지막 요소까지 반복\n    for (int i = 1; i < arr_len; i++) {\n        int key = arr[i]; // 현재 삽입할 값을 저장\n        int j = i - 1; // 정렬된 부분의 마지막 요소부터 비교 시작\n        \n        // key 값보다 큰 요소들을 오른쪽으로 이동\n        while (j >= 0 && arr[j] > key) {\n            arr[j + 1] = arr[j]; // 요소를 한 칸 오른쪽으로 이동\n            j--;\n        }\n        // key 값을 올바른 위치에 삽입\n        arr[j + 1] = key;\n    }\n}\n"
  },
  {
    "method": "quick",
    "code": "// 배열을 분할하는 함수 (피벗을 기준으로 배열을 두 부분으로 나눔)\nvoid heapify(int* arr, int n, int i) {\n    int largest = i;\n    int left = 2 * i + 1;\n    int right = 2 * i + 2;\n\n    // 왼쪽 자식이 루트보다 크다면 가장 큰 값을 왼쪽 자식으로 설정\n    if (left < n && arr[left] > arr[largest]) {\n        largest = left;\n    }\n\n    // 오른쪽 자식이 가장 큰 값보다 크다면 가장 큰 값을 오른쪽 자식으로 설정\n    if (right < n && arr[right] > arr[largest]) {\n        largest = right;\n    }\n\n    // 가장 큰 값이 루트가 아니라면 교환하고 힙 속성을 재정렬\n    if (largest != i) {\n        int temp = arr[i];\n        arr[i] = arr[largest];\n        arr[largest] = temp;\n\n        // 재귀적으로 힙 구조를 유지\n        heapify(arr, n, largest);\n    }\n}\n\n// 힙 정렬 메인 함수\nvoid heapSort(int* arr, int n) {\n    // 배열을 힙 구조로 변환 (최대 힙 생성)\n    for (int i = n / 2 - 1; i >= 0; i--) {\n        heapify(arr, n, i);\n    }\n\n    // 하나씩 요소를 힙에서 꺼내어 정렬\n    for (int i = n - 1; i > 0; i--) {\n        // 루트(가장 큰 값)와 마지막 요소를 교환\n        int temp = arr[0];\n        arr[0] = arr[i];\n        arr[i] = temp;\n\n        // 힙의 크기를 줄이고 힙 속성을 재정렬\n        heapify(arr, i, 0);\n    }\n}\n"
  },
  {
    "method": "heap",
    "code": "// 힙 구조를 유지하는 함수 (힙 정렬의 핵심 부분)\nvoid heapify(int* arr, int n, int i) {\n    int largest = i;\n    int left = 2 * i + 1;\n    int right = 2 * i + 2;  \n\n    // 왼쪽 자식이 루트보다 크다면 가장 큰 값을 왼쪽 자식으로 설정\n    if (left < n && arr[left] > arr[largest]) {\n        largest = left;\n    }\n\n    // 오른쪽 자식이 가장 큰 값보다 크다면 가장 큰 값을 오른쪽 자식으로 설정\n    if (right < n && arr[right] > arr[largest]) {\n        largest = right;\n    }\n\n    // 가장 큰 값이 루트가 아니라면 교환하고 힙 속성을 재정렬\n    if (largest != i) {\n        int temp = arr[i];\n        arr[i] = arr[largest];\n        arr[largest] = temp;\n\n        // 재귀적으로 힙 구조를 유지\n        heapify(arr, n, largest);\n    }\n}\n\n// 힙 정렬 메인 함수\nvoid heapSort(int* arr, int n) {\n    // 배열을 힙 구조로 변환 (최대 힙 생성)\n    for (int i = n / 2 - 1; i >= 0; i--) {\n        heapify(arr, n, i);\n    }\n\n    // 하나씩 요소를 힙에서 꺼내어 정렬\n    for (int i = n - 1; i > 0; i--) {\n        // 루트(가장 큰 값)와 마지막 요소를 교환\n        int temp = arr[0];\n        arr[0] = arr[i];\n        arr[i] = temp;\n\n        // 힙의 크기를 줄이고 힙 속성을 재정렬\n        heapify(arr, i, 0);\n    }\n}\n"
  },
  {
    "method": "radix",
    "code": "// 최대값을 구하는 함수\nint getMax(int* arr, int n) {\n    int max = arr[0];\n    for (int i = 1; i < n; i++) {\n        if (arr[i] > max) {\n            max = arr[i];\n        }\n    }\n    return max;\n}\n\n// 특정 자릿수에 대해 계수 정렬을 수행하는 함수\nvoid countSort(int* arr, int n, int exp) {\n    int output[n]; // 결과 배열\n    int count[10] = {0}; // 자릿수에 따른 카운트 배열\n\n    // 자릿수에 따라 count 배열에 저장\n    for (int i = 0; i < n; i++) {\n        count[(arr[i] / exp) % 10]++;\n    }\n\n    // count 배열을 업데이트하여 실제 위치 계산\n    for (int i = 1; i < 10; i++) {\n        count[i] += count[i - 1];\n    }\n\n    // 출력 배열을 작성\n    for (int i = n - 1; i >= 0; i--) {\n        output[count[(arr[i] / exp) % 10] - 1] = arr[i];\n        count[(arr[i] / exp) % 10]--;\n    }\n\n    // 원래 배열에 정렬된 결과 복사\n    for (int i = 0; i < n; i++) {\n        arr[i] = output[i];\n    }\n}\n\n// 기수 정렬 메인 함수\nvoid radixSort(int* arr, int n) {\n    // 배열에서 최대값을 구함\n    int max = getMax(arr, n);\n\n    // 자릿수별로 계수 정렬 수행\n    for (int exp = 1; max / exp > 0; exp *= 10) {\n        countSort(arr, n, exp);\n    }\n}"
  },
  {
    "method": "shell",
    "code": "// 셸 정렬 함수\nvoid shellSort(int* arr, int n) {\n    // 초기 간격을 배열 크기의 절반으로 설정\n    for (int gap = n / 2; gap > 0; gap /= 2) {\n        // 간격에 따라 삽입 정렬 수행\n        for (int i = gap; i < n; i++) {\n            int temp = arr[i];\n            int j;\n            // 삽입 정렬의 한 부분\n            for (j = i; j >= gap && arr[j - gap] > temp; j -= gap) {\n                arr[j] = arr[j - gap];\n            }\n            arr[j] = temp;\n        }\n    }\n}\n"
  }
]
